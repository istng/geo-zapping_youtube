<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Video with Shaders</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #youtube-player {
            width: 100%;
            height: 100%;
        }
        
        #shader-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            opacity: 0.7;
        }
        
        #add-video-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 4;
            padding: 10px 15px;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        #add-video-button:hover {
            background-color: rgba(255, 0, 0, 0.9);
        }
        
        #video-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 5;
            width: 80%;
            max-width: 500px;
        }
        
        #video-dialog h2 {
            color: white;
            margin-top: 0;
        }
        
        #video-dialog textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            margin: 10px 0;
            box-sizing: border-box;
            font-family: monospace;
        }
        
        #video-dialog button {
            padding: 10px 15px;
            margin-right: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #video-dialog button.cancel {
            background-color: #f44336;
        }
        
        #video-dialog p {
            color: #ccc;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <!-- This will be replaced by the YouTube API -->
        <div id="youtube-player"></div>
    </div>
    
    <canvas id="shader-canvas"></canvas>
    
    <button id="add-video-button">Add Videos</button>
    
    <div id="video-dialog">
        <h2>Add YouTube Videos</h2>
        <p>Paste YouTube URLs below (one per line):</p>
        <textarea id="video-urls" placeholder="https://www.youtube.com/watch?v=..."></textarea>
        <p>Examples: 
           <br>https://www.youtube.com/watch?v=dQw4w9WgXcQ
           <br>https://youtu.be/jNQXAC9IVRw
        </p>
        <button id="add-url-button">Add All</button>
        <button class="cancel" id="cancel-button">Cancel</button>
    </div>
    
    <script>
// YouTube video management
class YouTubeManager {
    constructor(videoContainerId) {
        this.videoContainer = document.getElementById(videoContainerId);
        this.currentVideoIndex = 0;
        this.currentPlayer = null;
        
        // List of videos with their IDs and timestamps
        this.videos = [
            {
                id: '8G9mEwdp8Vs',
                si: '7Q-V3wKojDNA6wkL',
                timestamp: 0
            },
            {
                id: 'T0kTiKCC3UI',
                si: 'someParam1',
                timestamp: 0
            },
            {
                id: 'jyAnVNn1fm8',
                si: 'someParam3',
                timestamp: 0
            }
        ];
        
        // Initialize YouTube API
        this.loadYouTubeAPI();
        
        // Set up keyboard controls
        this.setupKeyboardControls();
        
        // Set up add video dialog
        this.setupAddVideoDialog();
    }
    
    // Load the YouTube IFrame API
    loadYouTubeAPI() {
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        
        // Replace any existing content with a div for the YouTube player
        this.videoContainer.innerHTML = '<div id="youtube-player"></div>';
        
        // Define the callback for when the API is ready
        window.onYouTubeIframeAPIReady = () => this.createYouTubePlayer();
    }
    
    // Create the YouTube player
    createYouTubePlayer() {
        const video = this.videos[this.currentVideoIndex];
        this.currentPlayer = new YT.Player('youtube-player', {
            height: '100%',
            width: '100%',
            videoId: video.id,
            playerVars: {
                'autoplay': 1,
                'controls': 1,
                'start': Math.floor(video.timestamp),
                'loop': 1,
                'playlist': video.id
            },
            events: {
                'onStateChange': (event) => this.onPlayerStateChange(event)
            }
        });
    }
    
    // Save timestamp when video state changes
    onPlayerStateChange(event) {
        if (event.data == YT.PlayerState.PLAYING || 
            event.data == YT.PlayerState.PAUSED) {
            this.videos[this.currentVideoIndex].timestamp = this.currentPlayer.getCurrentTime();
        }
    }
    
    // Change to a specific video
    changeVideo(index) {
        // Save current timestamp before changing
        if (this.currentPlayer && this.currentPlayer.getCurrentTime) {
            this.videos[this.currentVideoIndex].timestamp = this.currentPlayer.getCurrentTime();
        }
        
        this.currentVideoIndex = index;
        const video = this.videos[this.currentVideoIndex];
        
        if (this.currentPlayer && this.currentPlayer.loadVideoById) {
            this.currentPlayer.loadVideoById({
                videoId: video.id,
                startSeconds: video.timestamp
            });
        }
    }
    
    // Go to previous video
    previousVideo() {
        const newIndex = (this.currentVideoIndex - 1 + this.videos.length) % this.videos.length;
        this.changeVideo(newIndex);
    }
    
    // Go to next video
    nextVideo() {
        const newIndex = (this.currentVideoIndex + 1) % this.videos.length;
        this.changeVideo(newIndex);
    }
    
    // Set up keyboard controls for video navigation
    setupKeyboardControls() {
        document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowUp') {
                this.previousVideo();
            } else if (event.key === 'ArrowDown') {
                this.nextVideo();
            }
        });
    }
    
    // Set up the add video dialog
    setupAddVideoDialog() {
        const addButton = document.getElementById('add-video-button');
        const dialog = document.getElementById('video-dialog');
        const urlsTextarea = document.getElementById('video-urls');
        const addUrlButton = document.getElementById('add-url-button');
        const cancelButton = document.getElementById('cancel-button');
        
        // Show dialog when add button is clicked
        addButton.addEventListener('click', () => {
            dialog.style.display = 'block';
            urlsTextarea.focus();
        });
        
        // Hide dialog when cancel is clicked
        cancelButton.addEventListener('click', () => {
            dialog.style.display = 'none';
            urlsTextarea.value = '';
        });
        
        // Add videos when add button in dialog is clicked
        addUrlButton.addEventListener('click', () => {
            this.processMultipleUrls(urlsTextarea.value);
            dialog.style.display = 'none';
            urlsTextarea.value = '';
        });
        
        // Also allow pressing Ctrl+Enter to add videos
        urlsTextarea.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && event.ctrlKey) {
                this.processMultipleUrls(urlsTextarea.value);
                dialog.style.display = 'none';
                urlsTextarea.value = '';
            }
        });
    }
    
    // Process multiple URLs from textarea
    processMultipleUrls(text) {
        // Split by newlines and filter out empty lines
        const urls = text.split('\n')
            .map(url => url.trim())
            .filter(url => url.length > 0);
        
        if (urls.length === 0) return;
        
        let addedCount = 0;
        let lastAddedIndex = -1;
        
        // Process each URL
        urls.forEach(url => {
            const result = this.addVideoFromUrl(url, false); // Don't switch to video yet
            if (result.added) {
                addedCount++;
                lastAddedIndex = result.index;
            }
        });
        
        // Show summary notification
        if (addedCount > 0) {
            this.showNotification(`Added ${addedCount} new videos! (${this.videos.length} videos total)`);
            
            // Switch to the last added video
            if (lastAddedIndex >= 0) {
                this.changeVideo(lastAddedIndex);
            }
        } else {
            this.showNotification('No new videos were added.');
        }
    }
    
    // Extract video ID from YouTube URL
    extractVideoId(url) {
        // Handle different YouTube URL formats
        const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
        const match = url.match(regExp);
        
        return (match && match[2].length === 11) ? match[2] : null;
    }
    
    // Add a new video from URL
    addVideoFromUrl(url, switchToVideo = true) {
        const videoId = this.extractVideoId(url);
        let result = { added: false, index: -1 };
        
        if (videoId) {
            // Check if video already exists in the list
            const exists = this.videos.some(video => video.id === videoId);
            
            if (!exists) {
                // Add new video to the list
                this.videos.push({
                    id: videoId,
                    si: 'userAdded',
                    timestamp: 0
                });
                
                result.added = true;
                result.index = this.videos.length - 1;
                
                // Show notification and switch if requested
                if (switchToVideo) {
                    this.showNotification(`Video added! (${this.videos.length} videos total)`);
                    this.changeVideo(result.index);
                }
            } else {
                // Find the index of the existing video
                const index = this.videos.findIndex(video => video.id === videoId);
                result.index = index;
                
                // Show notification and switch if requested
                if (switchToVideo) {
                    this.showNotification('Video already in list. Switching to it.');
                    this.changeVideo(index);
                }
            }
        } else if (switchToVideo) {
            this.showNotification('Invalid YouTube URL. Please try again.');
        }
        
        return result;
    }
    
    // Show a temporary notification
    showNotification(message) {
        // Create notification element if it doesn't exist
        let notification = document.getElementById('yt-notification');
        
        if (!notification) {
            notification = document.createElement('div');
            notification.id = 'yt-notification';
            notification.style.position = 'fixed';
            notification.style.top = '70px';
            notification.style.right = '20px';
            notification.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            notification.style.color = 'white';
            notification.style.padding = '10px 15px';
            notification.style.borderRadius = '5px';
            notification.style.zIndex = '5';
            notification.style.transition = 'opacity 0.5s';
            document.body.appendChild(notification);
        }
        
        // Set message and show notification
        notification.textContent = message;
        notification.style.opacity = '1';
        
        // Hide after 3 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
        }, 3000);
    }
} 
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize YouTube manager
            const youtubeManager = new YouTubeManager('video-container');
            
            const canvas = document.getElementById('shader-canvas');
            const gl = canvas.getContext('webgl');
            
            if (!gl) {
                console.error('WebGL not supported');
                return;
            }
            
            // Shader visibility state
            let shadersEnabled = true;
            
            // Function to toggle shader visibility
            function toggleShaders() {
                shadersEnabled = !shadersEnabled;
                canvas.style.display = shadersEnabled ? 'block' : 'none';
                updateShaderInfo();
            }
            
            // Shader management
            const shaders = [
                {
                    name: "Colorful Waves",
                    fragmentShader: `
                        precision highp float;
                        varying highp vec2 vTextureCoord;
                        uniform float uTime;
                        
                        void main(void) {
                            vec2 uv = vTextureCoord;
                            
                            // Create a colorful wave pattern
                            float r = 0.5 + 0.5 * sin(uv.x * 10.0 + uTime);
                            float g = 0.5 + 0.5 * sin(uv.y * 10.0 + uTime * 0.7);
                            float b = 0.5 + 0.5 * sin((uv.x + uv.y) * 5.0 + uTime * 1.3);
                            
                            // Add some moving waves
                            float wave = sin((uv.y * 20.0) + (uv.x * 10.0) + uTime * 2.0) * 0.1;
                            r += wave;
                            g += wave;
                            b += wave;
                            
                            gl_FragColor = vec4(r, g, b, 0.5); // Semi-transparent
                        }
                    `
                },
                {
                    name: "Plasma Effect",
                    fragmentShader: `
                        precision highp float;
                        varying highp vec2 vTextureCoord;
                        uniform float uTime;
                        
                        void main(void) {
                            vec2 uv = vTextureCoord;
                            
                            float v1 = sin(uv.x * 10.0 + uTime);
                            float v2 = sin(10.0 * (uv.x * sin(uTime / 2.0) + uv.y * cos(uTime / 3.0)) + uTime);
                            float v3 = sin(sqrt(100.0 * (uv.x * uv.x + uv.y * uv.y) + 1.0) + uTime);
                            
                            float cx = uv.x + sin(uTime / 5.0) * 0.5;
                            float cy = uv.y + cos(uTime / 3.0) * 0.5;
                            float v4 = sin(sqrt(100.0 * ((cx * cx) + (cy * cy))) + uTime);
                            
                            float plasma = (v1 + v2 + v3 + v4) / 4.0;
                            
                            float r = 0.5 + 0.5 * sin(plasma * 3.14159 + 0.0);
                            float g = 0.5 + 0.5 * sin(plasma * 3.14159 + 2.094);
                            float b = 0.5 + 0.5 * sin(plasma * 3.14159 + 4.188);
                            
                            gl_FragColor = vec4(r, g, b, 0.6);
                        }
                    `
                },
                {
                    name: "Kaleidoscope",
                    fragmentShader: `
                        precision highp float;
                        varying highp vec2 vTextureCoord;
                        uniform float uTime;
                        
                        void main(void) {
                            vec2 uv = vTextureCoord * 2.0 - 1.0;
                            
                            // Polar coordinates
                            float radius = length(uv);
                            float angle = atan(uv.y, uv.x);
                            
                            // Kaleidoscope effect
                            float segments = 8.0;
                            angle = mod(angle, 3.14159 * 2.0 / segments) - 3.14159 / segments;
                            
                            // Back to Cartesian
                            uv = radius * vec2(cos(angle), sin(angle));
                            
                            // Animate
                            uv += sin(uTime * 0.5) * 0.1;
                            
                            // Colors
                            float r = 0.5 + 0.5 * sin(radius * 5.0 - uTime);
                            float g = 0.5 + 0.5 * sin(radius * 7.0 - uTime * 1.3 + 2.0);
                            float b = 0.5 + 0.5 * sin(angle * 6.0 + uTime * 0.7);
                            
                            gl_FragColor = vec4(r, g, b, 0.5);
                        }
                    `
                },
                {
                    name: "Ripple",
                    fragmentShader: `
                        precision highp float;
                        varying highp vec2 vTextureCoord;
                        uniform float uTime;
                        
                        void main(void) {
                            vec2 uv = vTextureCoord * 2.0 - 1.0;
                            float dist = length(uv);
                            
                            // Create ripple effect
                            float ripple = sin(dist * 20.0 - uTime * 2.0) * 0.5 + 0.5;
                            
                            // Color based on distance and ripple
                            float r = ripple * (0.5 + 0.5 * sin(uTime));
                            float g = ripple * (0.5 + 0.5 * cos(uTime * 0.7));
                            float b = 0.5 + 0.5 * sin(dist * 5.0 + uTime);
                            
                            gl_FragColor = vec4(r, g, b, 0.5);
                        }
                    `
                },
                {
                    name: "Psychedelic Moiré",
                    fragmentShader: `
                        precision highp float;
                        varying highp vec2 vTextureCoord;
                        uniform float uTime;
                        
                        float pattern(vec2 p, float time) {
                            // Create multiple overlapping circular patterns
                            float scale1 = 15.0;
                            float scale2 = 12.0;
                            float scale3 = 9.0;
                            
                            // Animated centers for the patterns
                            vec2 center1 = vec2(0.5 + 0.3 * sin(time * 0.4), 0.5 + 0.3 * cos(time * 0.3));
                            vec2 center2 = vec2(0.5 + 0.4 * cos(time * 0.5), 0.5 + 0.4 * sin(time * 0.6));
                            vec2 center3 = vec2(0.5 + 0.2 * sin(time * 0.7), 0.5 + 0.2 * cos(time * 0.8));
                            
                            // Calculate distances from centers
                            float d1 = length((p - center1) * scale1);
                            float d2 = length((p - center2) * scale2);
                            float d3 = length((p - center3) * scale3);
                            
                            // Create circular patterns
                            float pattern1 = sin(d1 - time);
                            float pattern2 = sin(d2 - time * 1.5);
                            float pattern3 = sin(d3 - time * 0.7);
                            
                            // Combine patterns with different weights
                            return pattern1 * 0.5 + pattern2 * 0.3 + pattern3 * 0.2;
                        }
                        
                        void main(void) {
                            vec2 uv = vTextureCoord;
                            
                            // Apply distortion to UV coordinates
                            float distortionX = sin(uv.y * 10.0 + uTime * 0.5) * 0.02;
                            float distortionY = cos(uv.x * 8.0 + uTime * 0.6) * 0.02;
                            vec2 distortedUV = uv + vec2(distortionX, distortionY);
                            
                            // Generate base pattern
                            float p = pattern(distortedUV, uTime);
                            
                            // Create color bands based on the pattern
                            vec3 color;
                            color.r = 0.5 + 0.5 * sin(p * 3.14159 + uTime * 0.5);
                            color.g = 0.5 + 0.5 * sin(p * 3.14159 + uTime * 0.3 + 2.0);
                            color.b = 0.5 + 0.5 * sin(p * 3.14159 + uTime * 0.7 + 4.0);
                            
                            // Add zebra-like stripes
                            float stripePattern = sin(distortedUV.x * 40.0 + distortedUV.y * 40.0 + uTime * 2.0);
                            float stripeIntensity = smoothstep(0.3, 0.7, abs(stripePattern));
                            
                            // Mix colors with stripes
                            vec3 stripeColor = vec3(stripeIntensity);
                            color = mix(color, stripeColor, 0.3);
                            
                            // Add circular highlights
                            float highlight = smoothstep(0.4, 0.6, sin(length(uv - 0.5) * 10.0 - uTime));
                            color = mix(color, vec3(1.0), highlight * 0.2);
                            
                            gl_FragColor = vec4(color, 0.7);
                        }
                    `
                }
            ];
            
            let currentShaderIndex = 0;
            
            // Function to change the shader
            function changeShader(index) {
                currentShaderIndex = index;
                updateShaderInfo();
                
                // Recompile shader program
                const shaderProgram = initShaderProgram(gl, vsSource, shaders[currentShaderIndex].fragmentShader);
                
                // Update program info
                programInfo = {
                    program: shaderProgram,
                    attribLocations: {
                        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                        textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
                    },
                    uniformLocations: {
                        time: gl.getUniformLocation(shaderProgram, 'uTime'),
                    },
                };
            }
            
            // Update shader info display
            function updateShaderInfo() {
                const shaderInfo = document.getElementById('shader-info');
                if (shaderInfo) {
                    const statusText = shadersEnabled ? 'ON' : 'OFF';
                    shaderInfo.textContent = `Shader: ${shaders[currentShaderIndex].name} (${currentShaderIndex + 1}/${shaders.length}) - ${statusText}`;
                }
            }
            
            // Add keyboard event listener for shader controls
            document.addEventListener('keydown', function(event) {
                if (event.key === 'ArrowLeft') {
                    // Go to previous shader
                    currentShaderIndex = (currentShaderIndex - 1 + shaders.length) % shaders.length;
                    changeShader(currentShaderIndex);
                } else if (event.key === 'ArrowRight') {
                    // Go to next shader
                    currentShaderIndex = (currentShaderIndex + 1) % shaders.length;
                    changeShader(currentShaderIndex);
                } else if (event.key === 's' || event.key === 'S') {
                    // Toggle shader visibility
                    toggleShaders();
                }
            });
            
            // Resize canvas to match window size
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Vertex shader program
            const vsSource = `
                attribute vec4 aVertexPosition;
                attribute vec2 aTextureCoord;
                
                varying highp vec2 vTextureCoord;
                
                void main(void) {
                    gl_Position = aVertexPosition;
                    vTextureCoord = aTextureCoord;
                }
            `;
            
            // Initialize shader program
            function initShaderProgram(gl, vsSource, fsSource) {
                const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
                const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
                
                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                
                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }
                
                return shaderProgram;
            }
            
            // Create a shader
            function loadShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            // Initialize buffers
            function initBuffers(gl) {
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                
                // Create a square that covers the entire canvas
                const positions = [
                    -1.0, -1.0,
                     1.0, -1.0,
                    -1.0,  1.0,
                     1.0,  1.0,
                ];
                
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                
                const textureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
                
                const textureCoordinates = [
                    0.0, 0.0,
                    1.0, 0.0,
                    0.0, 1.0,
                    1.0, 1.0,
                ];
                
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
                
                return {
                    position: positionBuffer,
                    textureCoord: textureCoordBuffer,
                };
            }
            
            // Draw the scene
            function drawScene(gl, programInfo, buffers, time) {
                gl.clearColor(0.0, 0.0, 0.0, 0.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // Position attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    2, // 2 components per vertex
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
                
                // Texture coordinate attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.textureCoord,
                    2, // 2 components per texture coord
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);
                
                // Use the shader program
                gl.useProgram(programInfo.program);
                
                // Set the uniform
                gl.uniform1f(programInfo.uniformLocations.time, time);
                
                // Draw
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
            
            // Initialize shader program with the first shader
            let shaderProgram = initShaderProgram(gl, vsSource, shaders[currentShaderIndex].fragmentShader);
            
            // Collect all the info needed to use the shader program
            let programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                    textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
                },
                uniformLocations: {
                    time: gl.getUniformLocation(shaderProgram, 'uTime'),
                },
            };
            
            // Initialize buffers
            const buffers = initBuffers(gl);
            
            // Animation loop
            let startTime = Date.now();
            function render() {
                const currentTime = (Date.now() - startTime) / 1000; // time in seconds
                drawScene(gl, programInfo, buffers, currentTime);
                requestAnimationFrame(render);
            }
            
            // Start the animation loop
            requestAnimationFrame(render);
            
            // Add instructions to the page
            const instructions = document.createElement('div');
            instructions.innerHTML = `
                <div style="position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.5); color: white; padding: 10px; border-radius: 5px; z-index: 3;">
                    <p>Use ↑ and ↓ arrow keys to change videos</p>
                    <p>Use ← and → arrow keys to change shader effects</p>
                    <p>Press 'S' to toggle shaders on/off</p>
                    <p id="shader-info">Shader: ${shaders[currentShaderIndex].name} (1/${shaders.length}) - ON</p>
                </div>
            `;
            document.body.appendChild(instructions);
        }); 
    </script>
</body>
</html> 